package genfs

import (
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"time"
)

// Filter is a func that returns true for file names that should be included.
type Filter func(name string) bool

// ExcludeRegexp returns a filter func that excludes file paths matching the
// given expr, or an error.
func ExcludeRegexp(expr string) (Filter, error) {
	return regexpFilter(expr, true)
}

// IncludeRegexp returns a filter func that includes file paths matching the
// given expr, or an error.
func IncludeRegexp(expr string) (Filter, error) {
	return regexpFilter(expr, false)
}

func regexpFilter(expr string, exclude bool) (Filter, error) {
	r, err := regexp.CompilePOSIX(expr)
	if err != nil {
		return nil, err
	}
	return func(name string) bool {
		ok := r.MatchString(name)
		if exclude {
			ok = !ok
		}
		return ok
	}, nil
}

// Files recursively searches path and returns all files not excluded by the
// ignore filter or an error.
func Files(path string, filters ...Filter) ([]*File, error) {
	return files(path, path, filters)
}

func files(path, root string, filters []Filter) ([]*File, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	stat, err := file.Stat()
	if err != nil {
		return nil, err
	}
	for _, filter := range filters {
		if !filter(path) {
			return nil, nil
		}
	}
	relPath, err := filepath.Rel(root, path)
	if err != nil {
		return nil, err
	}
	result := &File{
		path:    relPath,
		name:    stat.Name(),
		isDir:   stat.IsDir(),
		size:    stat.Size(),
		mode:    stat.Mode(),
		modTime: stat.ModTime(),
	}
	if !stat.IsDir() {
		result.data, err = ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
		return []*File{result}, nil
	}
	children, err := file.Readdir(0)
	if err != nil {
		return nil, err
	}
	results := make([]*File, 0, len(children)+1)
	results = append(results, result)
	for _, child := range children {
		childResults, err := files(filepath.Join(path, child.Name()), root, filters)
		if err != nil {
			return nil, err
		}
		results = append(results, childResults...)
	}
	return results, nil
}

// WriteSource writes the the given files as Go source to w, using the given
// pkg name and varName. The varName is being assigned a http.FileSystem
// compatible fs in the init function of the generated file.
func WriteSource(w io.Writer, pkg, varName string, files []*File) error {

	return tmpl.Execute(w, struct {
		Package string
		Var     string
		Files   []*File
	}{pkg, varName, files})
}

var tmpl = template.Must(
	template.New("").
		Funcs(map[string]interface{}{
		"timeFormat": func(t time.Time) string {
			return t.Format(time.RFC3339Nano)
		},
	}).
		Parse(strings.TrimSpace(`
package {{.Package}}

// WARNING: Do not edit this file, it's generated by github.com/felixge/genfs.

import (
	"github.com/felixge/genfs"
)

func init () {
	{{.Var}} = genfs.NewFS({{range .Files}}
		genfs.NewFile(
			{{printf "%#v" .Path}},
			{{printf "%#v" .Name}},
			{{printf "%#v" .Size}},
			{{printf "%#v" .Mode}},
			genfs.MustTime({{printf "%#v" (timeFormat .ModTime)}}),
			{{printf "%#v" .IsDir}},
			[]byte({{printf "%#v" .String}}),
		),{{end}}
	)
}
`)))
